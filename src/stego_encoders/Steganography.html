<html>
<head>
<title>CSCI 0452 Final Project: Steganography </title>
</head>
<body>
	<h1> CSCI 0451 Final Project: Steganography </h1>
	<h4> Leveraging Image Processing to perform Steganography. </h4>
	<h5> By Rowen Felt, Julia Silva, and Casey Astiz</h5>
	<h5> Fall 2018</h5>

  <h4> Introduction </h4>
  <h5> Steganography is a way of hiding information inside of other formats in order to prevent detection. The word steganography actually comes from Greek and means “hidden writing” (Johnson and Jajodia). While steganography can be used in any context involving hiding information inside another format, it is particularly interesting in images because images with hidden information are visually indistinguishable from the original. Images can be used to hide any data, including plain text files or other images. When the information is combined, it is called a stego-image. Steganography is not to be confused with cryptography, where information is scrambled and unusable without the proper key but the key is known; rather, steganography hides information without the intruder knowing where or how the information is hidden. This method in the form of ciphers has been used historically, for example when Mary Queen of Scots was trying to assassinate Queen Elizabeth of England to take her thrown (Anderson and Petitcolas). Steganography is a very interesting technique, especially when incorporated with image processing.

The goal of our project is to create a steganography coder and decoder. Given two images, we would like to be able to “hide” one image inside of another. Given one image, we would like to decode the image to see what may be “hidden” within said image. Through these two processing steps, we will learn about bit manipulation in regards to images, as well as understand more about the granularity of an image (and how it is stored). Given time, we will also be attempting to make a streaming hidden image detector, where given a stream of images, it will detect which image has a valid image hidden within it. A valid image here is defined as anything other than random noise. Lastly, we will make a user friendly interface for people to upload images to encode or decode.</h5>


<h4> Methods </h4>
  <h5> There are several steganographic algorithms that can be used to obscure an image within another image, and all of them take advantage of high frequency noise within an image that can be modified without an observable change. The algorithm we will be using is based on storing a low resolution image (the hidden image) inside a higher resolution image (the base image) by flipping the least significant bits of adjacent values in the base image to represent pixel intensities of the hidden image. This method is called Least Significant Bit Insertion (Johnson and Jajodia). Flipping the least significant bit of a given pixel intensity can only change the color of that pixel by one hue, which is an imperceptibly change in color in a high frequency image with substantial color variation. To decode the image, the least significant bits of adjacent pixels are concatenated together to represent the pixel intensities or RGB color values of the hidden image’s pixels. We extend our decoder to create a streaming hidden image detector, images will be decoded and automatically classified as containing a hidden image or not based on some process separating images of random noise from real images by way of noise detection, edge detection, or some other process. This so called natural image detector predicts whether or not an image is natural after performing image processing techniques such as connected components analysis and edge detection. We lastly create a React app in order to host our project and allow for people to encode and decode the images of their choosing.
</h5>

  <h4> Results </h4>
    <h5> To date, we have completed some of the main points of our project. We have successfully implemented a least significant bit inserter in order to encode a hidden image within the cover image. We have also successfully implemented a decoder, pulling out the hidden image from the encoded image. Lastly, we have implemented a natural image detector, which predicts whether an image is a natural image versus a noise image. The point of this detector is to connect it to a decoder. The decoder will decode a set of images, and the natural image detector will predict which of these images are natural images and therefore which of the original images had hidden images in them.

We have been working on getting the coder to be faster and more efficient. Instead of about 4 minutes to encode, it only takes about 1 minutes. The decoder also has also become more efficient, finishing in about 1 minute as well. In addition, we have gotten the color encoder and decoder to function. This was one of our goals after the midway presentation. The last element we have been focusing on is the natural image detector. We have been working on multiple approaches, and testing them against a few examples. So far, it seems to be predicting our examples from class correctly as noise or natural image. We have tried three different approaches: connected component analysis, convolution edge detection, and canny edge detection. So far, the canny edge detection seems to be working the best because we can set the omega parameter to a point where it detects no edges in a noisy image but will detect some lines in a natural image. We are still currently working on our React app, and are still hoping to deploy it on basin.

  We do not have images to show in the results section, as successful image encoding and decoding results in images that are nearly identical or identical. For the final draft, we may include some photos anyways to show that there is an undetectable difference.
</h5>

<h4> Schedule </h4>

    <h5> Original plan:
The different components of the project are: the encoder, decoder, the streaming hidden image detector, and the UI. Our plan is to assign two weeks to complete the encoder/decoder, due by October 29. We will then create a test dataset to verify the accuracy of our devices by November 5. The project progress 3MT presentation will be held on October 30. We expect the implementation of the streaming hidden image detector to take about 20 days, thus it will be finalized by November 19. The UI and final touches are due on December 3, just ahead of our final project presentation on December 4. Any last modification to the code and UI will be implemented by the final project report date, December 12.

Outcome:

  We mostly have followed this plan we set out. The only element that has been taking a little more time than initially outlined for is the React App. We hope to have this finished and nice looking very soon, especially for the final version. The rest of the project has met these deadlines, and for the last bit of the project, we continue to improve and work on the extensions laid out in the future work section.
</h5>


  <h4> Issues </h4>
    <h5> We overcame several hurdles in implementing our encoder and decoder. Our first challenge was creating a steganographic encoding algorithm. We wrote our implementation independent of previous work on this topic. Therefore, we had to write our own bit encoding scheme and implement it in Python.
We also realized that because the hidden image has to be scaled appropriately to fit within the base image, not every pixel in the base image contains a bit from the hidden image. Therefore, we had to create a way to encode the dimensions of the hidden image in the bits of the base image. To accomplish this, we used the least significant bits of the first 24 pixels of the base image to encode two twelve-bit values, indicating the length and width of the hidden image. These values allow one to encode images of dimension 4095x4095.

Our other challenge was vectorization. We haven’t found a way to vectorize our encoding or decoding algorithms because each pixel is dependent on shifting the bits of the hidden image pixel from the previous iteration. Currently, encoding and decoding each take about three to four minutes to run for a large image.
Debugging also proved challenging because the output of the encoder and the input to the decoder is obfuscated by nature. We had to manually print out consecutive bytes and compare the binary to debug. This process allowed us to discover that we were originally encoding the pixel intensities of our hidden image as big-endian integers and decoding them as little-endian integers. We also discovered that our hidden image was being decoded as signed integers rather than unsigned integers, which created issues with shifting bits. After overcoming these hurdles, our encoder and decoder work correctly, but they still take considerable time to run.
</h5>


<h4> Future Work </h4>

  <h5> We are currently working on getting color encoder and decoder working. This was meant to happen earlier, but as discussed above, we have been having issues with our node.js app as well as fixing some bugs in our encoder. In addition, we plan to take our natural image detector and apply it to a set of photos to get a sense of the accuracy. Since we have multiple implementations of the natural image detector, we would like to experiment and see which one has the best performance. In addition, we want to test to see if there are some corner cases that the natural image detector implementations are not catching.

  An extension of this project as a whole, and not necessarily in an image processing context, could be to allow for any file to be hidden within the image. This isn’t as much an image processing question as hiding an image within an image, but is still interesting for the purpose of steganography. However, decoding that would be significantly more difficult, as you would not know what type of file to decode to. In addition, Johnson and Jajodia reference that you can use some sort of stego-key to encode the information, which would be an interesting element to add to this project.
  </h5>


  <h4> References </h4>
  <h5> N. F. Johnson and S. Jajodia, "Exploring steganography: Seeing the unseen," in Computer, vol. 31, no. 2, pp. 26-34, Feb. 1998. doi: 10.1109/MC.1998.4655281, URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4655281&isnumber=14232
Petitcolas, A.P. and Anderson, Ross J., “On the Limits of Steganography,” in IEEE Journal on Selected Areas in Communications, VOL. 16, NO. 4, MAY 1998. URL: https://www.cs.uaf.edu/2015/spring/cs463/lecture/04_06_stego/On_the_limits_of_steganography.pdf </h5>



<ul>
	<li> <a href = https://github.com/RowenFelt/Steganography-Project> Code Repository</a></li>
</ul>

<!-- <IMG SRC="https://cdn.edureka.co/blog/wp-content/uploads/2015/01/Decision_blog_animation_01-1.gif" width="500" height="600">
<IMG SRC= "https://static1.squarespace.com/static/5373bb24e4b02c5d204dc195/t/595a5978ccf210cc77d9083e/1499093374067/Plane.gif?format=2500w" width="500" height="600"> -->
</body>
</html>
